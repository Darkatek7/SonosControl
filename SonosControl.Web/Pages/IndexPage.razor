@page "/"
@using System.Text.RegularExpressions
@using System.Linq
@using Radzen.Blazor.Rendering
@using SonosControl.DAL.Interfaces
@using SonosControl.DAL.Models
@using SonosControl.Web.Data
@using SonosControl.Web.Models
@using SonosControl.Web.Pages.Index.Components
@inject ApplicationDbContext Db
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject INotificationService NotificationService
@attribute [Authorize(Roles = "admin,operator,superadmin")]

<PageTitle>Sonos Control</PageTitle>

@if (_settings is not null)
{
    <div class="container dashboard-shell">
        <div class="card dashboard-panel surface-0">
            <div class="card-body">
                <div class="d-flex flex-column flex-lg-row align-items-start justify-content-between mb-4 gap-3">
                    <div>
                        <h3 class="mb-1">üéõÔ∏è Sonos Control Panel</h3>
                        <p class="text-muted mb-0">Manage playback, queue, and curated sources for your Sonos system.</p>
                    </div>
                </div>

                <div class="dashboard-grid">
                    <div class="playback-column">
                        @if (_settings.Speakers.Any())
                        {
                            <div class="mb-3">
                                <label for="activeSpeakerSelect" class="form-label text-muted small">Active Speaker</label>
                                <div class="d-flex gap-2 align-items-center">
                                    <select id="activeSpeakerSelect" class="form-select" @bind="SelectedSpeakerIp">
                                        @foreach (var speaker in _settings.Speakers)
                                        {
                                            <option value="@speaker.IpAddress">@speaker.Name</option>
                                        }
                                    </select>
                                    <div class="btn-group">
                                        <button class="btn btn-outline-primary" @onclick="OpenGroupModal" disabled="@_isGrouping" title="Group speakers">
                                            @if (_isGrouping)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                            }
                                            else
                                            {
                                                <span>üîó Group</span>
                                            }
                                        </button>
                                        <button class="btn btn-outline-secondary" @onclick="UngroupCurrent" disabled="@_isGrouping" title="Ungroup active speaker">
                                            <span>‚õìÔ∏è‚Äçüí•</span>
                                        </button>
                                    </div>
                                    <button class="btn btn-outline-info" @onclick="SyncPlay" disabled="@_isSyncing" title="Play current media on all speakers">
                                        @if (_isSyncing)
                                        {
                                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                            <span class="visually-hidden">Syncing...</span>
                                        }
                                        else
                                        {
                                            <span>Sync Play</span>
                                        }
                                    </button>
                                </div>
                            </div>
                        }

                        <PlaybackCard
                            IsPlaying="_isPlaying"
                            IsLoading="_isMainPlaybackLoading"
                            ShowNextTrack="_isPlaying && _isSpotifyPlaying"
                            IsNextTrackLoading="_isNextTrackLoading"
                            Volume="Volume"
                            MaxVolumeLimit="MaxVolumeLimit"
                            GradientStyle="PlaybackCardStyle"
                            TogglePlay="Play"
                            VolumeChanged="@(value => Volume = value)"
                            OnOpenTimer="OpenTimerModal"
                            OnNextTrack="NextTrack" />

                        @if (_timerEndTimeUtc is not null)
                        {
                            var localStopTime = _timerEndTimeUtc.Value.ToLocalTime();
                            <div class="alert alert-info timed-playback-alert d-flex justify-content-between align-items-center mb-3">
                                <div>
                                    <strong>Timed Playback Active</strong>
                                    <p class="mb-0 text-muted">@(_timerSelectionName ?? "Playback") will stop at @localStopTime.ToString("t").</p>
                                </div>
                                <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="CancelTimedPlayback">Cancel</button>
                            </div>
                        }

                        <div class="card currently-playing-card">
                            <div class="card-body d-flex flex-column flex-md-row align-items-start gap-3">
                                @if (!string.IsNullOrWhiteSpace(currentTrackArtUrl))
                                {
                                    <img src="@currentTrackArtUrl" alt="Album Art" class="img-fluid rounded" style="max-width: 120px; max-height: 120px; object-fit: cover;" />
                                }
                                else
                                {
                                    <div class="display-5">üéµ</div>
                                }
                                <div class="flex-grow-1">
                                    <h5 class="mb-2">Currently Playing</h5>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Station:</strong> @currentStationDisplay</p>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Track:</strong> @currentlyPlaying</p>
                                    @if (!string.IsNullOrWhiteSpace(trackProgress))
                                    {
                                        <p class="mb-0 text-muted currently-playing-text"><strong>Time:</strong> @trackProgress</p>
                                    }
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="info-column">
                        <SectionCard Title="Speaker Status" Icon="üì¢">
                            <ChildContent>
                                <ul class="list-group list-group-flush media-list">
                                    @if (_speakerStatuses.Any())
                                    {
                                        @foreach (var status in _speakerStatuses.OrderBy(s => s.Name))
                                        {
                                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                                <div class="d-flex align-items-center">
                                                    <span class="me-2 status-indicator @(status.IsPlaying ? "status-playing" : "status-paused")"></span>
                                                    <div>
                                                        <span class="fw-bold">@status.Name</span>
                                                        @if (status.IsPlaying && !string.IsNullOrWhiteSpace(status.Media))
                                                        {
                                                            <br/>
                                                            <small class="text-muted">@status.Media</small>
                                                        }
                                                    </div>
                                                </div>
                                                <span class="badge rounded-pill text-uppercase @(status.IsPlaying ? "text-bg-success" : "text-bg-secondary")">
                                                    @(status.IsPlaying ? "Playing" : "Paused")
                                                </span>
                                            </li>
                                        }
                                    }
                                    else
                                    {
                                        <li class="list-group-item">No speakers to display.</li>
                                    }
                                </ul>
                            </ChildContent>
                        </SectionCard>
                        <hr/>
                        <SectionCard Title="Media Sources" Icon="üé∂">
                            <ChildContent>
                                <MediaTabs @bind-ActiveTab="_activeMediaTab">
                                    <StationsContent>
                                        @{
                                            var stations = _stations;
                                            <div class="d-flex justify-content-between align-items-center mb-3">
                                                <h5 class="mb-0">Saved Stations</h5>
                                                <div>
                                                    <button class="btn btn-sm btn-outline-secondary" @onclick="ShuffleStation" title="Play Random Station" aria-label="Play Random Station" disabled="@_isShuffleLoading">
                                                        @if (_isShuffleLoading)
                                                        {
                                                            <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                        }
                                                        else
                                                        {
                                                            <span>üîÄ</span>
                                                        }
                                                    </button>
                                                    <button class="btn btn-sm btn-primary" @onclick="ShowAddStationModal">‚ûï Add</button>
                                                </div>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (stations.Any())
                                                {
                                                    @foreach (var station in stations)
                                                    {
                                                        <li class="list-group-item @(IsCurrentlyPlaying(station.Url) ? "active-media" : "")">
                                                            <span>@station.Name</span>
                                                            <div class="media-actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(station.Url, "station"))" aria-label="Play @station.Name" disabled="@(_loadingMediaUrl == station.Url)">
                                                                    @if (_loadingMediaUrl == station.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveStation(station))" aria-label="Remove @station.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No stations saved.</li>
                                                }
                                            </ul>
                                        }
                                    </StationsContent>
                                    <SpotifyContent>
                                        @{
                                            var tracks = _tracks;
                                            <div class="d-flex justify-content-between align-items-center mb-3">
                                                <h5 class="mb-0">Saved Spotify</h5>
                                                <button class="btn btn-sm btn-primary" @onclick="ShowAddSpotifyModal">‚ûï Add</button>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (tracks.Any())
                                                {
                                                    @foreach (var track in tracks)
                                                    {
                                                        <li class="list-group-item @(IsCurrentlyPlaying(track.Url) ? "active-media" : "")">
                                                            <span>@track.Name</span>
                                                            <div class="media-actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(track.Url, "spotify"))" aria-label="Play @track.Name" disabled="@(_loadingMediaUrl == track.Url)">
                                                                    @if (_loadingMediaUrl == track.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveSpotifyTrack(track))" aria-label="Remove @track.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No Spotify tracks saved.</li>
                                                }
                                            </ul>
                                        }
                                    </SpotifyContent>
                                    <YouTubeContent>
                                        @{
                                            var collections = _youTubeCollections;
                                            <div class="d-flex justify-content-between align-items-center mb-3">
                                                <h5 class="mb-0">Saved YouTube</h5>
                                                <button class="btn btn-sm btn-primary" @onclick="ShowAddYouTubeModal">‚ûï Add</button>
                                            </div>
                                            <ul class="list-group media-list">
                                                @if (collections.Any())
                                                {
                                                    @foreach (var collection in collections)
                                                    {
                                                        <li class="list-group-item @(IsCurrentlyPlaying(collection.Url) ? "active-media" : "")">
                                                            <span>@collection.Name</span>
                                                            <div class="media-actions">
                                                                <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(collection.Url, "youtube"))" aria-label="Play @collection.Name" disabled="@(_loadingMediaUrl == collection.Url)">
                                                                    @if (_loadingMediaUrl == collection.Url)
                                                                    {
                                                                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                                    }
                                                                    else
                                                                    {
                                                                        <span>‚ñ∂Ô∏è</span>
                                                                    }
                                                                </button>
                                                                <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveYouTubeMusicEntry(collection))" aria-label="Remove @collection.Name">üóëÔ∏è</button>
                                                            </div>
                                                        </li>
                                                    }
                                                }
                                                else
                                                {
                                                    <li class="list-group-item text-muted">No YouTube collections saved.</li>
                                                }
                                            </ul>
                                        }
                                    </YouTubeContent>
                                </MediaTabs>
                        
                                <div class="mt-3">
                                    <h5 class="mb-2">üéß Play Spotify URL</h5>
                                    <div class="input-group">
                                        <input type="text"
                                               class="form-control"
                                               @bind-value="spotifyUrl"
                                               @bind-value:event="oninput"
                                               @onkeyup="HandleKeyPress"
                                               placeholder="Enter Spotify URL"
                                               aria-label="Spotify URL" />
                                        <button class="btn btn-primary" type="button" @onclick="SubmitSpotifyUrl" disabled="@_isSpotifyUrlLoading">
                                            @if (_isSpotifyUrlLoading)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                <span class="visually-hidden">Loading...</span>
                                            }
                                            else
                                            {
                                                <span>Play</span>
                                            }
                                        </button>
                                    </div>
                                </div>
                            </ChildContent>
                        </SectionCard>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<TimerModal
    Show="isTimerModalOpen"
    OnClose="CloseTimerModal"
    OnStart="StartTimedPlayback"
    TimerMinutes="timerMinutes"
    TimerMinutesChanged="value => timerMinutes = value"
    SelectedSource="timerSelection"
    SelectedSourceChanged="value => timerSelection = value"
    Stations="_stations"
    SpotifyTracks="_tracks"
    YouTubeCollections="_youTubeCollections"
    ErrorMessage="timerErrorMessage" />

<AddMediaItemModal @ref="_addMediaItemModal" OnSave="SaveNewMediaItem" ErrorMessage="@_addModalError" OnClose="() => _addModalError = null"/>

<GroupSpeakersModal Show="isGroupModalOpen"
                    Speakers="@(_settings?.Speakers ?? new())"
                    MasterIp="@SelectedSpeakerIp"
                    IsLoading="@_isGrouping"
                    OnClose="CloseGroupModal"
                    OnGroup="HandleCreateGroup" />

@code {
    public class SpeakerStatusViewModel
    {
        public string? Name { get; set; }
        public string? IpAddress { get; set; }
        public bool IsPlaying { get; set; }
        public string? Media { get; set; }
    }

    private List<SpeakerStatusViewModel> _speakerStatuses = new();
    private SonosSettings? _settings;
    private bool _isPlaying;
    private bool _isSyncing;
    private bool _isGrouping;
    private bool isGroupModalOpen;
    private bool _isMainPlaybackLoading;
    private bool _isNextTrackLoading;
    private bool _isSpotifyUrlLoading;
    private string? _loadingMediaUrl;
    private bool _isSpotifyPlaying;
    private string? spotifyUrl;
    private string? _selectedSpeakerIp;

    private string SelectedSpeakerIp
    {
        get => _selectedSpeakerIp ?? _settings?.IP_Adress ?? "";
        set
        {
            if (_selectedSpeakerIp != value)
            { 
                _selectedSpeakerIp = value;
                if (_settings != null)
                {
                    _ = UpdateSpeakerRelatedData(value);
                }
            }
        }
    }

    private async Task UpdateSpeakerRelatedData(string newIpAddress)
    {
        _settings.IP_Adress = newIpAddress;
        await SaveSettings();

        try
        {
            _settings.Volume = await _uow.ISonosConnectorRepo.GetVolume(newIpAddress);
        }
        catch
        {
            // Ignore if speaker is offline or returns error
            _settings.Volume = 0; // Default to 0 or last known good if error
        }

        // Refresh data for the new speaker
        await UpdatePageDataAsync();
    }

    // New state for tabs and modal
    private string _activeMediaTab = "stations";
    private AddMediaItemModal _addMediaItemModal = default!;
    private string? _addModalError;


    private int Volume
    {
        get
        {
            if (_settings is null)
            {
                return 0;
            }

            var limit = MaxVolumeLimit;
            return Math.Min(_settings.Volume, limit);
        }
        set
        {
            if (_settings is null)
            {
                return;
            }

            var limit = MaxVolumeLimit;
            var clamped = Math.Clamp(value, 0, limit);

            if (_settings.Volume == clamped)
            {
                return;
            }

            _settings.Volume = clamped;
            _ = _uow.ISonosConnectorRepo.SetVolume(_settings.IP_Adress, clamped);
            _ = SaveSettings();
        }
    }

    private int MaxVolumeLimit => Math.Clamp(_settings?.MaxVolume ?? 100, 0, 100);

    private string? PlaybackCardStyle => !_isPlaying || _settings is null
        ? null
        : $"background: linear-gradient(135deg, {NormalizeColor(_settings.NowPlayingGradientStartColor, SonosSettings.DefaultNowPlayingGradientStartColor)} 0%, {NormalizeColor(_settings.NowPlayingGradientMidColor, SonosSettings.DefaultNowPlayingGradientMidColor)} 55%, {NormalizeColor(_settings.NowPlayingGradientEndColor, SonosSettings.DefaultNowPlayingGradientEndColor)} 100%);";

    private bool isAuthenticated;
    private bool isAdmin;
    private bool isOperator;

    private bool isTimerModalOpen;
    private int timerMinutes = 60;
    private string? timerSelection;
    private string? timerErrorMessage;
    private CancellationTokenSource? _playbackTimerCts;
    private DateTime? _timerEndTimeUtc;
    private string? _timerSelectionName;

    private string currentStationUrl = "Loading...";
    private string currentStationDisplay = "Loading...";

    private string currentlyPlaying = "Loading...";
    private string? currentTrackArtUrl;
    private string trackProgress = "";
    private Timer? _stationUpdateTimer;

    private List<TuneInStation> _stations =>
        (_settings?.Stations ?? new List<TuneInStation>())
        .OrderBy(s => s.Name)
        .ToList();

    private List<SpotifyObject> _tracks =>
        (_settings?.SpotifyTracks ?? new List<SpotifyObject>())
        .OrderBy(t => t.Name)
        .ToList();

    private List<YouTubeMusicObject> _youTubeCollections =>
        (_settings?.YouTubeMusicCollections ?? new List<YouTubeMusicObject>())
        .OrderBy(t => t.Name)
        .ToList();

    private async Task UpdatePageDataAsync()
    {
        // Execute data fetching in parallel to reduce cycle time
        var loadStationTask = LoadCurrentStation();
        var updateStatusesTask = UpdateSpeakerStatuses();
        await Task.WhenAll(loadStationTask, updateStatusesTask);

        // OPTIMIZATION: Populate the Media property for the selected speaker using the data
        // that was already fetched by LoadCurrentStation, avoiding redundant network calls.
        var selectedStatus = _speakerStatuses.FirstOrDefault(s => s.IpAddress == SelectedSpeakerIp);
        if (selectedStatus != null && selectedStatus.IsPlaying && string.IsNullOrEmpty(selectedStatus.Media))
        {
            // Note: currentlyPlaying is now already validated in LoadCurrentStation via IsValidMetadata()
            // However, "No metadata available" is a valid value for UI but shouldn't be the 'Media' if we have a station name.
            bool isTrackValid = !string.IsNullOrWhiteSpace(currentlyPlaying) && currentlyPlaying != "No metadata available";

            if (isTrackValid)
            {
                selectedStatus.Media = currentlyPlaying;
            }
            else if (currentStationDisplay.Contains("Spotify", StringComparison.OrdinalIgnoreCase))
            {
                selectedStatus.Media = "Spotify";
            }
            else if (currentStationDisplay.Contains("YouTube", StringComparison.OrdinalIgnoreCase))
            {
                selectedStatus.Media = "YouTube Music";
            }
            else
            {
                selectedStatus.Media = currentStationDisplay != "Loading..." ? currentStationDisplay : "Playing stream";
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    private void UpdatePageData(object? _ = null)
    {
        _ = InvokeAsync(UpdatePageDataAsync);
    }

    private async Task UpdateSpeakerStatuses()
    {
        if (_settings?.Speakers == null)
        {
            _speakerStatuses = new();
            return;
        }

        var tasks = _settings.Speakers.Select(async speaker =>
        {
            try
            {
                var isPlaying = await _uow.ISonosConnectorRepo.IsPlaying(speaker.IpAddress);

                // OPTIMIZATION: If this is the selected speaker, update main state and skip redundant fetches.
                // The main view data (Track, Station) is fetched in parallel by LoadCurrentStation.
                if (speaker.IpAddress == SelectedSpeakerIp)
                {
                    _isPlaying = isPlaying;
                    // We return a partial VM here; UpdatePageDataAsync will fill in the Media property
                    // using the data fetched by LoadCurrentStation to avoid double-fetching.
                    return new SpeakerStatusViewModel
                    {
                        Name = speaker.Name,
                        IpAddress = speaker.IpAddress,
                        IsPlaying = isPlaying,
                        Media = null // Will be populated in UpdatePageDataAsync
                    };
                }

                string media = "";
                if (isPlaying)
                {
                    // Use GetTrackInfoAsync to allow validation
                    var trackInfoTask = _uow.ISonosConnectorRepo.GetTrackInfoAsync(speaker.IpAddress);
                    var rawStationUrlTask = _uow.ISonosConnectorRepo.GetCurrentStationAsync(speaker.IpAddress);

                    await Task.WhenAll(trackInfoTask, rawStationUrlTask);

                    var trackInfo = await trackInfoTask;
                    var rawStationUrl = await rawStationUrlTask;
                    var currentStationUrl = rawStationUrl?.Replace("x-rincon-mp3radio://", "").Trim() ?? "";

                    if (trackInfo != null && trackInfo.IsValidMetadata())
                    {
                        media = trackInfo.GetDisplayString();
                    }
                    else if (currentStationUrl.Contains("spotify", StringComparison.OrdinalIgnoreCase))
                    {
                        media = "Spotify";
                    }
                    else if (currentStationUrl.Contains("youtube", StringComparison.OrdinalIgnoreCase))
                    {
                        media = "YouTube Music";
                    }
                    else
                    {
                        var matched = _stations.FirstOrDefault(s => currentStationUrl != null && s.Url != null && currentStationUrl.Contains(s.Url, StringComparison.OrdinalIgnoreCase));
                        if (matched != null)
                        {
                            media = matched.Name;
                        }
                        else
                        {
                            media = "Playing stream";
                        }
                    }
                }

                return new SpeakerStatusViewModel
                {
                    Name = speaker.Name,
                    IpAddress = speaker.IpAddress,
                    IsPlaying = isPlaying,
                    Media = media
                };
            }
            catch
            {
                return new SpeakerStatusViewModel
                {
                    Name = speaker.Name,
                    IpAddress = speaker.IpAddress,
                    IsPlaying = false,
                    Media = "Offline"
                };
            }
        }).ToList();

        _speakerStatuses = (await Task.WhenAll(tasks)).ToList();
    }


    private async Task LoadCurrentStation()
    {
        if (_settings is not null)
        {
            // Execute fetching in parallel
            var stationTask = _uow.ISonosConnectorRepo.GetCurrentStationAsync(_settings.IP_Adress);
            var trackInfoTask = _uow.ISonosConnectorRepo.GetTrackInfoAsync(_settings.IP_Adress);
            var progressTask = _uow.ISonosConnectorRepo.GetTrackProgressAsync(_settings.IP_Adress);

            await Task.WhenAll(stationTask, trackInfoTask, progressTask);

            var rawStationUrl = await stationTask;
            currentStationUrl = rawStationUrl?.Replace("x-rincon-mp3radio://", "").Trim() ?? "";

            if (currentStationUrl.Contains("spotify", StringComparison.OrdinalIgnoreCase))
            {
                currentStationDisplay = "Spotify";
                _isSpotifyPlaying = true;
            }
            else if (currentStationUrl.Contains("youtube", StringComparison.OrdinalIgnoreCase))
            {
                currentStationDisplay = "YouTube Music";
                _isSpotifyPlaying = false;
            }
            else
            {
                // Try to match with saved stations first
                var matched = _stations.FirstOrDefault(s => currentStationUrl?.Contains(s.Url, StringComparison.OrdinalIgnoreCase) == true);
                if (matched != null)
                {
                    currentStationDisplay = matched.Name;
                }
                else
                {
                    currentStationDisplay = currentStationUrl;
                }

                _isSpotifyPlaying = false;
            }

            var trackInfo = await trackInfoTask;
            if (trackInfo != null && trackInfo.IsValidMetadata())
            {
                 currentlyPlaying = trackInfo.GetDisplayString();
                 currentTrackArtUrl = trackInfo.AlbumArtUri;
            }
            else
            {
                // Fallback to station display if track info is invalid/missing
                currentlyPlaying = "No metadata available";
                currentTrackArtUrl = null;

                // Attempt to use the Station Name if available and track is invalid
                if (!string.IsNullOrWhiteSpace(currentStationDisplay) && currentStationDisplay != "Loading...")
                {
                    // If we are playing a station, we might want to show the Station Name as "Track"
                    // or just leave "currentlyPlaying" as "No metadata" and let the "Station:" field show it.
                    // The previous logic put the Station Name into "Media" in the list.
                    // Here, "Currently Playing" card has separate Station and Track fields.
                    // If Track is garbage, we leave it empty or "No metadata".
                    currentlyPlaying = "No metadata available";
                }
            }

            var progress = await progressTask;

            if (progress.Duration == TimeSpan.Zero)
            {
                trackProgress = progress.Position == TimeSpan.Zero
                    ? string.Empty
                    : $"{progress.Position:mm\\:ss}";
            }
            else
            {
                trackProgress = $"{progress.Position:mm\\:ss} / {progress.Duration:mm\\:ss}";
            }
        }
    }
    
    private bool IsCurrentlyPlaying(string url)
    {
        if (string.IsNullOrEmpty(url) || string.IsNullOrEmpty(currentStationUrl))
        {
            return false;
        }
        // Normalize and compare, this might need to be more robust
        return currentStationUrl.Contains(url, StringComparison.OrdinalIgnoreCase);
    }

    private async Task PlayMediaItem(string url, string type)
    {
        if (string.IsNullOrEmpty(url) || _settings is null) return;

        _loadingMediaUrl = url;
        await InvokeAsync(StateHasChanged);

        try
        {
            switch (type)
            {
                case "station":
                    await _uow.ISonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, url);
                    await AddLog("Station Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"Station changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
                case "spotify":
                    await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
                    await AddLog("Spotify Track Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"Spotify track changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
                case "youtube":
                    await _uow.ISonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, url, _settings.AutoPlayStationUrl);
                    await AddLog("YouTube Music Changed", $"URL: {url}");
                    await NotificationService.SendNotificationAsync($"YouTube Music changed to {url} on {SelectedSpeakerIp}", await GetCurrentUserAsync());
                    break;
            }
            await _uow.ISonosConnectorRepo.StartPlaying(_settings.IP_Adress);
        }
        finally
        {
            _loadingMediaUrl = null;
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (!string.IsNullOrEmpty(spotifyUrl))
            {
                await PlaySpotifyTrack(spotifyUrl);
                spotifyUrl = string.Empty; // Clear the input field after submission
            }
        }
    }

    private async Task SubmitSpotifyUrl()
    {
        if (!string.IsNullOrWhiteSpace(spotifyUrl))
        {
            await PlaySpotifyTrack(spotifyUrl);
            spotifyUrl = string.Empty;
        }
    }

    private async Task PlaySpotifyTrack(string url)
    {
        if (_settings is not null)
        {
            _isSpotifyUrlLoading = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
                await AddLog("Spotify URL Played", url);
            }
            finally
            {
                _isSpotifyUrlLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private async Task NextTrack()
    {
        _isNextTrackLoading = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            await _uow.ISonosConnectorRepo.NextTrack(SelectedSpeakerIp);
            await AddLog("Next Track");
        }
        finally
        {
            _isNextTrackLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void OpenTimerModal()
    {
        timerErrorMessage = null;

        if (timerMinutes <= 0)
        {
            timerMinutes = 60;
        }

        isTimerModalOpen = true;
    }

    private void CloseTimerModal()
    {
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private async Task StartTimedPlayback()
    {
        timerErrorMessage = null;

        if (_settings is null)
        {
            timerErrorMessage = "Settings are not loaded.";
            return;
        }

        if (timerMinutes <= 0)
        {
            timerErrorMessage = "Please enter a duration greater than zero.";
            return;
        }

        if (string.IsNullOrWhiteSpace(timerSelection))
        {
            timerErrorMessage = "Please select a playback source.";
            return;
        }

        var parts = timerSelection.Split('|', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2)
        {
            timerErrorMessage = "Invalid selection.";
            return;
        }

        var selectionType = parts[0];
        var selectionValue = parts[1];
        string selectionName;
        string logSource;

        try
        {
            if (selectionType == "station")
            {
                var station = _stations.FirstOrDefault(s => s.Url == selectionValue);
                selectionName = station?.Name ?? selectionValue;
                logSource = $"Station: {selectionName}";
                await _uow.ISonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = false;
            }
            else if (selectionType == "spotify")
            {
                var track = _tracks.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = track?.Name ?? selectionValue;
                logSource = $"Spotify: {selectionName}";
                await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = true;
            }
            else if (selectionType == "youtube")
            {
                var entry = _youTubeCollections.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = entry?.Name ?? selectionValue;
                logSource = $"YouTube Music: {selectionName}";
                await _uow.ISonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, selectionValue, _settings.AutoPlayStationUrl);
                _isSpotifyPlaying = false;
            }
            else
            {
                timerErrorMessage = "Invalid source selected.";
                return;
            }

            await _uow.ISonosConnectorRepo.StartPlaying(_settings.IP_Adress);
            _isPlaying = true;

            var minutes = timerMinutes;
            var ip = _settings.IP_Adress;

            _playbackTimerCts?.Cancel();
            _playbackTimerCts?.Dispose();
            _playbackTimerCts = null;

            await AddLog("Timed Playback Started", $"{logSource} ({minutes} minutes)");

            _timerSelectionName = selectionName;
            _timerEndTimeUtc = DateTime.UtcNow.AddMinutes(minutes);

            isTimerModalOpen = false;
            timerSelection = null;
            timerMinutes = 60;

            _playbackTimerCts = new CancellationTokenSource();
            var cts = _playbackTimerCts;

            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromMinutes(minutes), cts.Token);
                    await InvokeAsync(async () =>
                    {
                        await _uow.ISonosConnectorRepo.PausePlaying(ip);
                        _isPlaying = false;
                        _timerEndTimeUtc = null;
                        _timerSelectionName = null;
                        await AddLog("Timed Playback Completed", $"{logSource} ({minutes} minutes)");
                        StateHasChanged();
                    });
                }
                catch (TaskCanceledException)
                {
                }
                finally
                {
                    if (ReferenceEquals(_playbackTimerCts, cts))
                    {
                        _playbackTimerCts = null;
                    }

                    cts.Dispose();
                }
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(ex);
            timerErrorMessage = "Failed to start timed playback.";
        }
    }

    private async Task CancelTimedPlayback()
    {
        var cts = _playbackTimerCts;
        if (cts is not null)
        {
            _playbackTimerCts = null;
            cts.Cancel();
            cts.Dispose();
        }

        if (_timerEndTimeUtc is not null || _timerSelectionName is not null)
        {
            var stopInfo = _timerEndTimeUtc?.ToLocalTime().ToString("t");
            var details = _timerSelectionName ?? "Timed playback";
            if (!string.IsNullOrEmpty(stopInfo))
            {
                details += $" (scheduled stop at {stopInfo})";
            }

            await AddLog("Timed Playback Cancelled", details);
        }

        _timerEndTimeUtc = null;
        _timerSelectionName = null;
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private static string NormalizeColor(string? value, string fallback)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return fallback;
        }

        var trimmed = value.Trim();

        if (!trimmed.StartsWith("#", System.StringComparison.Ordinal))
        {
            trimmed = $"#{trimmed.TrimStart('#')}";
        }

        if (trimmed.Length == 7)
        {
            return trimmed;
        }

        if (trimmed.Length == 4)
        {
            return $"#{trimmed[1]}{trimmed[1]}{trimmed[2]}{trimmed[2]}{trimmed[3]}{trimmed[3]}";
        }

        if (trimmed.Length > 7)
        {
            return trimmed.Substring(0, 7);
        }

        return fallback;
    }

    private async Task AddLog(string action, string? details = null)
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var username = user.Identity?.Name ?? "Unknown";

        var log = new LogEntry
        {
            Action = action,
            PerformedBy = username,
            Timestamp = DateTime.UtcNow,
            Details = details
        };

        Db.Logs.Add(log);
        await Db.SaveChangesAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        isAuthenticated = user.Identity?.IsAuthenticated ?? false;
        if (!isAuthenticated)
        {
            Navigation.NavigateTo("/auth/login?", true);
            return;
        }

        _settings = await _uow.ISettingsRepo.GetSettings();
        _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();

        if (_settings.Speakers.Any())
        {
             // Use the first speaker or the last selected one if available
            if (string.IsNullOrEmpty(_selectedSpeakerIp) || !_settings.Speakers.Any(s => s.IpAddress == _selectedSpeakerIp))
            {
                 _selectedSpeakerIp = _settings.Speakers.First().IpAddress;
                 _settings.IP_Adress = _selectedSpeakerIp;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && isAuthenticated && _settings != null)
        {
            try
            {
                if (_settings.Speakers.Any() && !(_settings.IP_Adress is "10.0.0.0"))
                {
                    // OPTIMIZATION: Run volume initialization and page data update in parallel
                    // The _isPlaying state is now updated within UpdatePageDataAsync (via UpdateSpeakerStatuses),
                    // removing the need for a separate sequential IsPlaying() call.
                    await Task.WhenAll(
                        EnsureVolumeAsync(),
                        UpdatePageDataAsync()
                    );

                    _stationUpdateTimer = new Timer(UpdatePageData, null, 3000, 3000);
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error in OnAfterRenderAsync: {ex}");
            }
        }
    }

    private async Task EnsureVolumeAsync()
    {
        try
        {
            _settings!.Volume = await _uow.ISonosConnectorRepo.GetVolume(SelectedSpeakerIp);
        }
        catch
        {
            // Ignore if speaker is offline
        }

        var maxVolumeLimit = MaxVolumeLimit;
        if (_settings!.Volume > maxVolumeLimit)
        {
            _settings.Volume = maxVolumeLimit;
            await _uow.ISonosConnectorRepo.SetVolume(SelectedSpeakerIp, maxVolumeLimit);
        }

        await SaveSettings();
    }

    private async Task Play(bool play)
    {
        _isMainPlaybackLoading = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            if (play)
            {
                await _uow.ISonosConnectorRepo.StartPlaying(SelectedSpeakerIp);
                _isPlaying = true;
                await AddLog("Playback Started");
                await NotificationService.SendNotificationAsync($"Playback started on {SelectedSpeakerIp}", await GetCurrentUserAsync());
            }
            else
            {
                await _uow.ISonosConnectorRepo.PausePlaying(SelectedSpeakerIp);
                _isPlaying = false;
                await AddLog("Playback Paused");
                await NotificationService.SendNotificationAsync($"Playback paused on {SelectedSpeakerIp}", await GetCurrentUserAsync());
            }
        }
        finally
        {
            _isMainPlaybackLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task SyncPlay()
    {
        if (_isSyncing) return;
        if (_settings?.Speakers == null || !_settings.Speakers.Any()) return;

        _isSyncing = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            var slaveIps = _settings.Speakers.Where(s => s.IpAddress != SelectedSpeakerIp).Select(s => s.IpAddress).ToList();
            await ApplyLegacySync(SelectedSpeakerIp, slaveIps);

            await AddLog("Sync Play Started (Cloned URI)", "All speakers");
            await NotificationService.SendNotificationAsync($"Sync Play triggered for all speakers (Legacy sync)", await GetCurrentUserAsync());
        }
        finally
        {
            _isSyncing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ApplyLegacySync(string masterIp, IEnumerable<string> slaveIps)
    {
        var currentUri = await _uow.ISonosConnectorRepo.GetCurrentStationAsync(masterIp);

        var tasks = slaveIps.Select(async slaveIp =>
        {
             if (currentUri.StartsWith("x-rincon-mp3radio://") || currentUri.StartsWith("http"))
            {
                await _uow.ISonosConnectorRepo.SetTuneInStationAsync(slaveIp, currentUri);
            }

            await _uow.ISonosConnectorRepo.StartPlaying(slaveIp);
        });

        await Task.WhenAll(tasks);
    }

    private void OpenGroupModal() => isGroupModalOpen = true;
    private void CloseGroupModal() => isGroupModalOpen = false;

    private async Task HandleCreateGroup(List<string> slaveIps)
    {
        if (slaveIps == null || !slaveIps.Any()) return;

        _isGrouping = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            // Stop slave speakers first to ensure clean grouping
            await Task.WhenAll(slaveIps.Select(ip => _uow.ISonosConnectorRepo.StopPlaying(ip)));

            // Try to create the group via UPnP
            bool success = await _uow.ISonosConnectorRepo.CreateGroup(SelectedSpeakerIp, slaveIps);

            if (success)
            {
                await AddLog("Group Created", $"Master: {SelectedSpeakerIp}, Slaves: {string.Join(", ", slaveIps)}");
                await NotificationService.SendNotificationAsync($"Group created with master {SelectedSpeakerIp}", await GetCurrentUserAsync());
            }
            else
            {
                Console.WriteLine("Native grouping failed. Falling back to legacy sync.");
                await AddLog("Group Creation Failed - Fallback", $"Master: {SelectedSpeakerIp}. Attempting legacy sync.");
                await ApplyLegacySync(SelectedSpeakerIp, slaveIps);
                await NotificationService.SendNotificationAsync($"Group failed (UPnP error). Fallback Sync started for {SelectedSpeakerIp}", await GetCurrentUserAsync());
            }

            isGroupModalOpen = false;
        }
        catch (Exception ex)
        {
            await AddLog("Group Creation Failed", ex.Message);
            await NotificationService.SendNotificationAsync($"Group creation failed for master {SelectedSpeakerIp}: {ex.Message}", await GetCurrentUserAsync());
        }
        finally
        {
            _isGrouping = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task UngroupCurrent()
    {
        _isGrouping = true;
        await InvokeAsync(StateHasChanged);
        try
        {
            await _uow.ISonosConnectorRepo.UngroupSpeaker(SelectedSpeakerIp);
            await AddLog("Speaker Ungrouped", SelectedSpeakerIp);
            await NotificationService.SendNotificationAsync($"Speaker {SelectedSpeakerIp} ungrouped", await GetCurrentUserAsync());
        }
        finally
        {
            _isGrouping = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task<string> GetCurrentUserAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        return authState.User.Identity?.Name ?? "Unknown";
    }

    private async Task<bool> IsPlaying()
    {
        return await _uow.ISonosConnectorRepo.IsPlaying(SelectedSpeakerIp);
    }

    private async Task SaveSettings()
    {
        await _uow.ISettingsRepo.WriteSettings(_settings!);
    }

    private void ShowAddStationModal() => _addMediaItemModal.Show("Add New Station");
    private void ShowAddSpotifyModal() => _addMediaItemModal.Show("Add New Spotify Item");
    private void ShowAddYouTubeModal() => _addMediaItemModal.Show("Add New YouTube Music Item");

    private async Task SaveNewMediaItem((string Name, string Url) data)
    {
        _addModalError = null;
        _settings ??= new SonosSettings();

        switch (_activeMediaTab)
        {
            case "stations":
                _settings.Stations ??= new List<TuneInStation>();
                if (_settings.Stations.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Station with this name or URL already exists.";
                    return;
                }
                _settings.Stations.Add(new TuneInStation { Name = data.Name, Url = data.Url });
                await AddLog("Station Added", $"{data.Name} ({data.Url})");
                break;
            case "spotify":
                _settings.SpotifyTracks ??= new List<SpotifyObject>();
                 if (_settings.SpotifyTracks.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Spotify item with this name or URL already exists.";
                    return;
                }
                _settings.SpotifyTracks.Add(new SpotifyObject { Name = data.Name, Url = data.Url });
                await AddLog("Spotify Track Added", $"{data.Name} ({data.Url})");
                break;
            case "youtube":
                _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();
                 if (_settings.YouTubeMusicCollections.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "YouTube item with this name or URL already exists.";
                    return;
                }
                _settings.YouTubeMusicCollections.Add(new YouTubeMusicObject { Name = data.Name, Url = data.Url });
                await AddLog("YouTube Music Link Added", $"{data.Name} ({data.Url})");
                break;
        }
        
        await SaveSettings();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveStation(TuneInStation station)
    {
        if (_settings?.Stations is null) return;

        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete station '{station.Name}'?");
        if (!confirmed) return;

        _settings.Stations.Remove(station);
        await SaveSettings();

        await AddLog("Station Removed", $"{station.Name} ({station.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveSpotifyTrack(SpotifyObject track)
    {
        if (_settings?.SpotifyTracks is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete track '{track.Name}'?");
        if (!confirmed) return;

        _settings.SpotifyTracks.Remove(track);
        await SaveSettings();

        await AddLog("Spotify Track Removed", $"{track.Name} ({track.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveYouTubeMusicEntry(YouTubeMusicObject entry)
    {
        if (_settings?.YouTubeMusicCollections is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete link '{entry.Name}'?");
        if (!confirmed) return;

        _settings.YouTubeMusicCollections.Remove(entry);
        await SaveSettings();

        await AddLog("YouTube Music Link Removed", $"{entry.Name} ({entry.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private Random _random = new();

    private bool _isShuffleLoading;

    private async Task ShuffleStation()
    {
        if (_settings?.Stations != null && _settings.Stations.Any())
        {
            _isShuffleLoading = true;
            await InvokeAsync(StateHasChanged);
            try
            {
                var randomStation = _settings.Stations[_random.Next(_settings.Stations.Count)].Url;
                await PlayMediaItem(randomStation, "station");
            }
            finally
            {
                _isShuffleLoading = false;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        _stationUpdateTimer?.Dispose();
        _stationUpdateTimer = null;

        var playbackCts = _playbackTimerCts;
        if (playbackCts is not null)
        {
            _playbackTimerCts = null;
            playbackCts.Cancel();
            playbackCts.Dispose();
        }
    }
}
