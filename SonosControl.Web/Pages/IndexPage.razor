@page "/"
@using System.Text.RegularExpressions
@using SonosControl.DAL.Interfaces
@using SonosControl.DAL.Models
@using SonosControl.Web.Data
@using SonosControl.Web.Models
@using SonosControl.Web.Pages.Index.Components
@inject ApplicationDbContext Db
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JS
@inject NavigationManager Navigation
@attribute [Authorize(Roles = "admin,operator,superadmin")]

<PageTitle>Sonos Control</PageTitle>

@if (_settings is not null)
{
    <div class="container dashboard-shell">
        <div class="card dashboard-panel surface-0">
            <div class="card-body">
                <div class="d-flex flex-column flex-lg-row align-items-start justify-content-between mb-4 gap-3">
                    <div>
                        <h3 class="mb-1">üéõÔ∏è Sonos Control Panel</h3>
                        <p class="text-muted mb-0">Manage playback, queue, and curated sources for your Sonos system.</p>
                    </div>
                    <div class="toolbar-actions">
                        <p class="text-muted mb-0 small">Playback status refreshes automatically.</p>
                    </div>
                </div>

                <div class="dashboard-grid">
                    <div class="playback-column">
                        @if (_settings.Speakers.Any())
                        {
                            <div class="mb-3">
                                <label class="form-label text-muted small">Active Speaker</label>
                                <div class="d-flex gap-2">
                                    <select class="form-select" @bind="SelectedSpeakerIp">
                                        @foreach (var speaker in _settings.Speakers)
                                        {
                                            <option value="@speaker.IpAddress">@speaker.Name</option>
                                        }
                                    </select>
                                    <button class="btn btn-outline-info" @onclick="SyncPlay" title="Play current media on all speakers">Sync Play</button>
                                </div>
                            </div>
                        }

                        <PlaybackCard
                            IsPlaying="_isPlaying"
                            ShowNextTrack="_isPlaying && _isSpotifyPlaying"
                            Volume="Volume"
                            MaxVolumeLimit="MaxVolumeLimit"
                            GradientStyle="PlaybackCardStyle"
                            TogglePlay="Play"
                            VolumeChanged="@(value => Volume = value)"
                            OnOpenTimer="OpenTimerModal"
                            OnNextTrack="NextTrack" />

                        @if (_timerEndTimeUtc is not null)
                        {
                            var localStopTime = _timerEndTimeUtc.Value.ToLocalTime();
                            <div class="alert alert-info timed-playback-alert d-flex justify-content-between align-items-center mb-3">
                                <div>
                                    <strong>Timed Playback Active</strong>
                                    <p class="mb-0 text-muted">@(_timerSelectionName ?? "Playback") will stop at @localStopTime.ToString("t").</p>
                                </div>
                                <button type="button" class="btn btn-sm btn-outline-secondary" @onclick="CancelTimedPlayback">Cancel</button>
                            </div>
                        }

                        <div class="card currently-playing-card">
                            <div class="card-body d-flex flex-column flex-md-row align-items-start gap-3">
                                <div class="display-5">üéµ</div>
                                <div class="flex-grow-1">
                                    <h5 class="mb-2">Currently Playing</h5>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Station:</strong> @currentStationDisplay</p>
                                    <p class="mb-1 text-muted currently-playing-text"><strong>Track:</strong> @currentlyPlaying</p>
                                    @if (!string.IsNullOrWhiteSpace(trackProgress))
                                    {
                                        <p class="mb-0 text-muted currently-playing-text"><strong>Time:</strong> @trackProgress</p>
                                    }
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="queue-column">
                        <QueuePanel
                            Items="@queue"
                            IsLoading="@_queueIsLoading"
                            HasMore="@_queueHasMore"
                            AutoRefreshEnabled="@QueueAutoRefreshEnabled"
                            RefreshIntervalSeconds="@_queueRefreshIntervalSeconds"
                            RefreshIntervals="@_queueRefreshIntervals"
                            ErrorMessage="@_queueErrorMessage"
                            Refresh="() => LoadQueue(reset: true)"
                            LoadMore="LoadNextQueuePage"
                            AutoRefreshChanged="value => QueueAutoRefreshEnabled = value"
                            RefreshIntervalChanged="UpdateQueueRefreshInterval"
                            FormatItem="FormatQueueItem" />
                    </div>

                    <div class="media-column">
                        <MediaTabs @bind-ActiveTab="_activeMediaTab">
                            <StationsContent>
                                @{
                                    var stations = _stations;
                                    <div class="d-flex justify-content-between align-items-center mb-3">
                                        <h5 class="mb-0">Saved Stations</h5>
                                        <div>
                                            <button class="btn btn-sm btn-outline-secondary" @onclick="ShuffleStation" title="Play Random Station">üîÄ</button>
                                            <button class="btn btn-sm btn-primary" @onclick="ShowAddStationModal">‚ûï Add</button>
                                        </div>
                                    </div>
                                    <ul class="list-group media-list">
                                        @foreach (var station in stations)
                                        {
                                            <li class="list-group-item @(IsCurrentlyPlaying(station.Url) ? "active-media" : "")">
                                                <span>@station.Name</span>
                                                <div class="media-actions">
                                                    <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(station.Url, "station"))">‚ñ∂Ô∏è</button>
                                                    <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveStation(station))">üóëÔ∏è</button>
                                                </div>
                                            </li>
                                        }
                                    </ul>
                                }
                            </StationsContent>
                            <SpotifyContent>
                                @{
                                    var tracks = _tracks;
                                    <div class="d-flex justify-content-between align-items-center mb-3">
                                        <h5 class="mb-0">Saved Spotify</h5>
                                        <button class="btn btn-sm btn-primary" @onclick="ShowAddSpotifyModal">‚ûï Add</button>
                                    </div>
                                    <ul class="list-group media-list">
                                        @foreach (var track in tracks)
                                        {
                                            <li class="list-group-item @(IsCurrentlyPlaying(track.Url) ? "active-media" : "")">
                                                <span>@track.Name</span>
                                                <div class="media-actions">
                                                    <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(track.Url, "spotify"))">‚ñ∂Ô∏è</button>
                                                    <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveSpotifyTrack(track))">üóëÔ∏è</button>
                                                </div>
                                            </li>
                                        }
                                    </ul>
                                }
                            </SpotifyContent>
                            <YouTubeContent>
                                @{
                                    var collections = _youTubeCollections;
                                    <div class="d-flex justify-content-between align-items-center mb-3">
                                        <h5 class="mb-0">Saved YouTube</h5>
                                        <button class="btn btn-sm btn-primary" @onclick="ShowAddYouTubeModal">‚ûï Add</button>
                                    </div>
                                    <ul class="list-group media-list">
                                        @foreach (var collection in collections)
                                        {
                                            <li class="list-group-item @(IsCurrentlyPlaying(collection.Url) ? "active-media" : "")">
                                                <span>@collection.Name</span>
                                                <div class="media-actions">
                                                    <button class="btn btn-sm btn-success" @onclick="@(() => PlayMediaItem(collection.Url, "youtube"))">‚ñ∂Ô∏è</button>
                                                    <button class="btn btn-sm btn-danger" @onclick="@(() => RemoveYouTubeMusicEntry(collection))">üóëÔ∏è</button>
                                                </div>
                                            </li>
                                        }
                                    </ul>
                                }
                            </YouTubeContent>
                        </MediaTabs>
                        
                        <div class="card media-section mt-3">
                            <div class="card-header">
                                <h5 class="mb-0">üéß Play Spotify URL</h5>
                            </div>
                            <div class="card-body">
                                <div class="input-group">
                                    <input type="text"
                                           class="form-control"
                                           @bind-value="spotifyUrl"
                                           @bind-value:event="oninput"
                                           @onkeyup="HandleKeyPress"
                                           placeholder="Enter Spotify URL"
                                           aria-label="Spotify URL" />
                                    <button class="btn btn-primary" type="button" @onclick="SubmitSpotifyUrl">Play</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<TimerModal
    Show="isTimerModalOpen"
    OnClose="CloseTimerModal"
    OnStart="StartTimedPlayback"
    TimerMinutes="timerMinutes"
    TimerMinutesChanged="value => timerMinutes = value"
    SelectedSource="timerSelection"
    SelectedSourceChanged="value => timerSelection = value"
    Stations="_stations"
    SpotifyTracks="_tracks"
    YouTubeCollections="_youTubeCollections"
    ErrorMessage="timerErrorMessage" />

<AddMediaItemModal @ref="_addMediaItemModal" OnSave="SaveNewMediaItem" ErrorMessage="@_addModalError" OnClose="() => _addModalError = null"/>

@code {

    private SonosSettings? _settings;
    private bool _isPlaying;
    private bool _isSpotifyPlaying;
    private string? spotifyUrl;
    private string? _selectedSpeakerIp;

    private string SelectedSpeakerIp
    {
        get => _selectedSpeakerIp ?? _settings?.IP_Adress ?? "";
        set
        {
            if (_selectedSpeakerIp != value)
            {
                _selectedSpeakerIp = value;
                if (_settings != null)
                {
                    // Update the main IP address setting to match selection for compatibility
                    _settings.IP_Adress = value;
                    _ = SaveSettings();

                    // Refresh data for the new speaker
                    _ = LoadCurrentStation();
                    _ = LoadQueue(reset: true);
                }
            }
        }
    }

    // New state for tabs and modal
    private string _activeMediaTab = "stations";
    private AddMediaItemModal _addMediaItemModal = default!;
    private string? _addModalError;


    private int Volume
    {
        get
        {
            if (_settings is null)
            {
                return 0;
            }

            var limit = MaxVolumeLimit;
            return Math.Min(_settings.Volume, limit);
        }
        set
        {
            if (_settings is null)
            {
                return;
            }

            var limit = MaxVolumeLimit;
            var clamped = Math.Clamp(value, 0, limit);

            if (_settings.Volume == clamped)
            {
                return;
            }

            _settings.Volume = clamped;
            _ = _uow.ISonosConnectorRepo.SetVolume(_settings.IP_Adress, clamped);
            _ = SaveSettings();
        }
    }

    private int MaxVolumeLimit => Math.Clamp(_settings?.MaxVolume ?? 100, 0, 100);

    private string? PlaybackCardStyle => !_isPlaying || _settings is null
        ? null
        : $"background: linear-gradient(135deg, {NormalizeColor(_settings.NowPlayingGradientStartColor, SonosSettings.DefaultNowPlayingGradientStartColor)} 0%, {NormalizeColor(_settings.NowPlayingGradientMidColor, SonosSettings.DefaultNowPlayingGradientMidColor)} 55%, {NormalizeColor(_settings.NowPlayingGradientEndColor, SonosSettings.DefaultNowPlayingGradientEndColor)} 100%);";

    private bool isAuthenticated;
    private bool isAdmin;
    private bool isOperator;

    private bool isTimerModalOpen;
    private int timerMinutes = 60;
    private string? timerSelection;
    private string? timerErrorMessage;
    private CancellationTokenSource? _playbackTimerCts;
    private DateTime? _timerEndTimeUtc;
    private string? _timerSelectionName;

    private string currentStationUrl = "Loading...";
    private string currentStationDisplay = "Loading...";

    private string currentlyPlaying = "Loading...";
    private string trackProgress = "";
    private Timer? _stationUpdateTimer;

    private List<TuneInStation> _stations =>
        (_settings?.Stations ?? new List<TuneInStation>())
        .OrderBy(s => s.Name)
        .ToList();

    private List<SpotifyObject> _tracks =>
        (_settings?.SpotifyTracks ?? new List<SpotifyObject>())
        .OrderBy(t => t.Name)
        .ToList();

    private List<YouTubeMusicObject> _youTubeCollections =>
        (_settings?.YouTubeMusicCollections ?? new List<YouTubeMusicObject>())
        .OrderBy(t => t.Name)
        .ToList();
    
    private List<SonosQueueItem> queue = new();
    private const int QueuePageSize = 50;
    private int _queueNextIndex;
    private bool _queueHasMore;
    private bool _queueIsLoading;
    private string? _queueErrorMessage;
    private bool _queueAutoRefreshEnabled;
    private readonly int[] _queueRefreshIntervals = new[] { 15, 30, 60, 120 };
    private int _queueRefreshIntervalSeconds = 30;
    private CancellationTokenSource? _queueRefreshCts;
    private Task? _queueRefreshTask;

    private async Task LoadCurrentStation()
    {
        if (_settings is not null)
        {
            var rawStationUrl = await _uow.ISonosConnectorRepo.GetCurrentStationAsync(_settings.IP_Adress);
            currentStationUrl = rawStationUrl.Replace("x-rincon-mp3radio://", "").Trim();

            if (currentStationUrl.Contains("spotify", StringComparison.OrdinalIgnoreCase))
            {
                currentStationDisplay = "Spotify";
                _isSpotifyPlaying = true;
            }
            else if (currentStationUrl.Contains("youtube", StringComparison.OrdinalIgnoreCase))
            {
                currentStationDisplay = "YouTube Music";
                _isSpotifyPlaying = false;
            }
            else
            {
                // Try to match with saved stations first
                var matched = _stations.FirstOrDefault(s => currentStationUrl?.Contains(s.Url, StringComparison.OrdinalIgnoreCase) == true);
                if (matched != null)
                {
                    currentStationDisplay = matched.Name;
                }
                else
                {
                    currentStationDisplay = currentStationUrl;
                }

                _isSpotifyPlaying = false;
            }

            currentlyPlaying = await _uow.ISonosConnectorRepo.GetCurrentTrackAsync(_settings.IP_Adress);
            var progress = await _uow.ISonosConnectorRepo.GetTrackProgressAsync(_settings.IP_Adress);

            if (progress.Duration == TimeSpan.Zero)
            {
                trackProgress = progress.Position == TimeSpan.Zero
                    ? string.Empty
                    : $"{progress.Position:mm\\:ss}";
            }
            else
            {
                trackProgress = $"{progress.Position:mm\\:ss} / {progress.Duration:mm\\:ss}";
            }

            await InvokeAsync(StateHasChanged);
        }
    }
    
    private bool IsCurrentlyPlaying(string url)
    {
        if (string.IsNullOrEmpty(url) || string.IsNullOrEmpty(currentStationUrl))
        {
            return false;
        }
        // Normalize and compare, this might need to be more robust
        return currentStationUrl.Contains(url, StringComparison.OrdinalIgnoreCase);
    }

    private async Task PlayMediaItem(string url, string type)
    {
        if (string.IsNullOrEmpty(url) || _settings is null) return;

        switch (type)
        {
            case "station":
                await _uow.ISonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, url);
                await AddLog("Station Changed", $"URL: {url}");
                break;
            case "spotify":
                await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
                await AddLog("Spotify Track Changed", $"URL: {url}");
                break;
            case "youtube":
                 await _uow.ISonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, url, _settings.AutoPlayStationUrl);
                 await AddLog("YouTube Music Changed", $"URL: {url}");
                break;
        }
        await _uow.ISonosConnectorRepo.StartPlaying(_settings.IP_Adress);
    }
    
    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (!string.IsNullOrEmpty(spotifyUrl))
            {
                await PlaySpotifyTrack(spotifyUrl);
                spotifyUrl = string.Empty; // Clear the input field after submission
            }
        }
    }

    private async Task SubmitSpotifyUrl()
    {
        if (!string.IsNullOrWhiteSpace(spotifyUrl))
        {
            await PlaySpotifyTrack(spotifyUrl);
            spotifyUrl = string.Empty;
        }
    }

    private async Task PlaySpotifyTrack(string url)
    {
        if (_settings is not null)
        {
            await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, url);
            await AddLog("Spotify URL Played", url);
        }
    }

    private async Task NextTrack()
    {
        await _uow.ISonosConnectorRepo.NextTrack(SelectedSpeakerIp);
        await AddLog("Next Track");
    }

    private async Task LoadQueue(bool reset = false, CancellationToken cancellationToken = default)
    {
        if (_settings is null || _queueIsLoading)
        {
            return;
        }

        cancellationToken.ThrowIfCancellationRequested();

        var startIndex = reset ? 0 : _queueNextIndex;

        try
        {
            _queueIsLoading = true;
            _queueErrorMessage = null;

            if (reset)
            {
                _queueNextIndex = 0;
                _queueHasMore = false;
            }

            var page = await _uow.ISonosConnectorRepo.GetQueue(_settings.IP_Adress, startIndex, QueuePageSize, cancellationToken);

            if (reset)
            {
                queue = new List<SonosQueueItem>(page.Items);
            }
            else if (page.StartIndex == startIndex)
            {
                queue.AddRange(page.Items);
            }
            else
            {
                queue = new List<SonosQueueItem>(page.Items);
            }

            _queueNextIndex = page.StartIndex + page.NumberReturned;
            _queueHasMore = page.HasMore;
        }
        catch (OperationCanceledException)
        {
        }
        catch (Exception ex)
        {
            _queueErrorMessage = "Unable to load queue.";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            _queueIsLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private Task LoadNextQueuePage()
    {
        if (!_queueHasMore)
        {
            return Task.CompletedTask;
        }

        return LoadQueue(reset: false);
    }

    private bool QueueAutoRefreshEnabled
    {
        get => _queueAutoRefreshEnabled;
        set
        {
            if (_queueAutoRefreshEnabled == value)
            {
                return;
            }

            _queueAutoRefreshEnabled = value;

            if (value)
            {
                StartQueueAutoRefresh();
            }
            else
            {
                StopQueueAutoRefresh();
            }
        }
    }

    private Task UpdateQueueRefreshInterval(int seconds)
    {
        if (seconds <= 0)
        {
            return Task.CompletedTask;
        }

        _queueRefreshIntervalSeconds = seconds;
        if (_queueAutoRefreshEnabled)
        {
            StartQueueAutoRefresh();
        }

        return Task.CompletedTask;
    }

    private void StartQueueAutoRefresh()
    {
        CancelQueueAutoRefreshLoop();

        var cts = new CancellationTokenSource();
        _queueRefreshCts = cts;
        var token = cts.Token;

        _queueRefreshTask = Task.Run(async () =>
        {
            try
            {
                await InvokeAsync(() => LoadQueue(reset: true, cancellationToken: token));
                using var timer = new PeriodicTimer(TimeSpan.FromSeconds(_queueRefreshIntervalSeconds));
                while (await timer.WaitForNextTickAsync(token))
                {
                    await InvokeAsync(() => LoadQueue(reset: true, cancellationToken: token));
                }
            }
            catch (OperationCanceledException)
            {
            }
            catch (ObjectDisposedException)
            {
            }
        });
    }

    private void StopQueueAutoRefresh(bool updateFlag = false)
    {
        CancelQueueAutoRefreshLoop();
        if (updateFlag)
        {
            _queueAutoRefreshEnabled = false;
        }
    }

    private void CancelQueueAutoRefreshLoop()
    {
        var cts = _queueRefreshCts;
        if (cts is null)
        {
            return;
        }

        _queueRefreshCts = null;

        try
        {
            cts.Cancel();
        }
        catch (ObjectDisposedException)
        {
        }
        finally
        {
            cts.Dispose();
        }
    }

    private static string FormatQueueItem(SonosQueueItem item)
    {
        var title = string.IsNullOrWhiteSpace(item.Title) ? "Unknown title" : item.Title;
        return string.IsNullOrWhiteSpace(item.Artist)
            ? title
            : $"{item.Artist} ‚Äì {title}";
    }

    private void OpenTimerModal()
    {
        timerErrorMessage = null;

        if (timerMinutes <= 0)
        {
            timerMinutes = 60;
        }

        isTimerModalOpen = true;
    }

    private void CloseTimerModal()
    {
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private async Task StartTimedPlayback()
    {
        timerErrorMessage = null;

        if (_settings is null)
        {
            timerErrorMessage = "Settings are not loaded.";
            return;
        }

        if (timerMinutes <= 0)
        {
            timerErrorMessage = "Please enter a duration greater than zero.";
            return;
        }

        if (string.IsNullOrWhiteSpace(timerSelection))
        {
            timerErrorMessage = "Please select a playback source.";
            return;
        }

        var parts = timerSelection.Split('|', 2, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length != 2)
        {
            timerErrorMessage = "Invalid selection.";
            return;
        }

        var selectionType = parts[0];
        var selectionValue = parts[1];
        string selectionName;
        string logSource;

        try
        {
            if (selectionType == "station")
            {
                var station = _stations.FirstOrDefault(s => s.Url == selectionValue);
                selectionName = station?.Name ?? selectionValue;
                logSource = $"Station: {selectionName}";
                await _uow.ISonosConnectorRepo.SetTuneInStationAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = false;
            }
            else if (selectionType == "spotify")
            {
                var track = _tracks.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = track?.Name ?? selectionValue;
                logSource = $"Spotify: {selectionName}";
                await _uow.ISonosConnectorRepo.PlaySpotifyTrackAsync(_settings.IP_Adress, selectionValue);
                _isSpotifyPlaying = true;
            }
            else if (selectionType == "youtube")
            {
                var entry = _youTubeCollections.FirstOrDefault(t => t.Url == selectionValue);
                selectionName = entry?.Name ?? selectionValue;
                logSource = $"YouTube Music: {selectionName}";
                await _uow.ISonosConnectorRepo.PlayYouTubeMusicTrackAsync(_settings.IP_Adress, selectionValue, _settings.AutoPlayStationUrl);
                _isSpotifyPlaying = false;
            }
            else
            {
                timerErrorMessage = "Invalid source selected.";
                return;
            }

            await _uow.ISonosConnectorRepo.StartPlaying(_settings.IP_Adress);
            _isPlaying = true;

            var minutes = timerMinutes;
            var ip = _settings.IP_Adress;

            _playbackTimerCts?.Cancel();
            _playbackTimerCts?.Dispose();
            _playbackTimerCts = null;

            await AddLog("Timed Playback Started", $"{logSource} ({minutes} minutes)");

            _timerSelectionName = selectionName;
            _timerEndTimeUtc = DateTime.UtcNow.AddMinutes(minutes);

            isTimerModalOpen = false;
            timerSelection = null;
            timerMinutes = 60;

            _playbackTimerCts = new CancellationTokenSource();
            var cts = _playbackTimerCts;

            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(TimeSpan.FromMinutes(minutes), cts.Token);
                    await InvokeAsync(async () =>
                    {
                        await _uow.ISonosConnectorRepo.PausePlaying(ip);
                        _isPlaying = false;
                        _timerEndTimeUtc = null;
                        _timerSelectionName = null;
                        await AddLog("Timed Playback Completed", $"{logSource} ({minutes} minutes)");
                        StateHasChanged();
                    });
                }
                catch (TaskCanceledException)
                {
                }
                finally
                {
                    if (ReferenceEquals(_playbackTimerCts, cts))
                    {
                        _playbackTimerCts = null;
                    }

                    cts.Dispose();
                }
            });
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine(ex);
            timerErrorMessage = "Failed to start timed playback.";
        }
    }

    private async Task CancelTimedPlayback()
    {
        var cts = _playbackTimerCts;
        if (cts is not null)
        {
            _playbackTimerCts = null;
            cts.Cancel();
            cts.Dispose();
        }

        if (_timerEndTimeUtc is not null || _timerSelectionName is not null)
        {
            var stopInfo = _timerEndTimeUtc?.ToLocalTime().ToString("t");
            var details = _timerSelectionName ?? "Timed playback";
            if (!string.IsNullOrEmpty(stopInfo))
            {
                details += $" (scheduled stop at {stopInfo})";
            }

            await AddLog("Timed Playback Cancelled", details);
        }

        _timerEndTimeUtc = null;
        _timerSelectionName = null;
        isTimerModalOpen = false;
        timerErrorMessage = null;
    }

    private static string NormalizeColor(string? value, string fallback)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return fallback;
        }

        var trimmed = value.Trim();

        if (!trimmed.StartsWith("#", System.StringComparison.Ordinal))
        {
            trimmed = $"#{trimmed.TrimStart('#')}";
        }

        if (trimmed.Length == 7)
        {
            return trimmed;
        }

        if (trimmed.Length == 4)
        {
            return $"#{trimmed[1]}{trimmed[1]}{trimmed[2]}{trimmed[2]}{trimmed[3]}{trimmed[3]}";
        }

        if (trimmed.Length > 7)
        {
            return trimmed.Substring(0, 7);
        }

        return fallback;
    }

    private async Task AddLog(string action, string? details = null)
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        var username = user.Identity?.Name ?? "Unknown";

        var log = new LogEntry
        {
            Action = action,
            PerformedBy = username,
            Timestamp = DateTime.UtcNow,
            Details = details
        };

        Db.Logs.Add(log);
        await Db.SaveChangesAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        isAuthenticated = user.Identity?.IsAuthenticated ?? false;
        if (!isAuthenticated)
        {
            Navigation.NavigateTo("/auth/login?", true);
            return;
        }

        _settings = await _uow.ISettingsRepo.GetSettings();
        _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();

        if (_settings.Speakers.Any())
        {
             // Use the first speaker or the last selected one if available
            if (string.IsNullOrEmpty(_selectedSpeakerIp) || !_settings.Speakers.Any(s => s.IpAddress == _selectedSpeakerIp))
            {
                 _selectedSpeakerIp = _settings.Speakers.First().IpAddress;
                 _settings.IP_Adress = _selectedSpeakerIp;
            }
        }
        else if (_settings!.IP_Adress is "10.0.0.0")
        {
             // No speakers and default IP, just return
             return;
        }

        try
        {
            _settings!.Volume = await _uow.ISonosConnectorRepo.GetVolume(SelectedSpeakerIp);
        }
        catch
        {
             // Ignore if speaker is offline
        }

        var maxVolumeLimit = MaxVolumeLimit;
        if (_settings.Volume > maxVolumeLimit)
        {
            _settings.Volume = maxVolumeLimit;
            await _uow.ISonosConnectorRepo.SetVolume(SelectedSpeakerIp, maxVolumeLimit);
        }

        await SaveSettings();
        _isPlaying = await IsPlaying();
        await LoadCurrentStation();
        await LoadQueue(reset: true);
        _stationUpdateTimer = new Timer(async _ => await LoadCurrentStation(), null, 1000, 1000);
    }

    private async Task Play(bool play)
    {
        if (play)
        {
            await _uow.ISonosConnectorRepo.StartPlaying(SelectedSpeakerIp);
            _isPlaying = true;
            await AddLog("Playback Started");
        }
        else
        {
            await _uow.ISonosConnectorRepo.PausePlaying(SelectedSpeakerIp);
            _isPlaying = false;
            await AddLog("Playback Paused");
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task SyncPlay()
    {
        if (_settings?.Speakers == null || !_settings.Speakers.Any()) return;

        // Determine what to play based on current state of the selected speaker
        // However, Sonos "Join Group" is not implemented in repo, so we just start playback on all speakers
        // If we want to play the SAME content, we would need to know the current content URL.
        // For now, let's just send the "Play" command to all speakers.
        // A better approach if supported would be to set the URI for all speakers to the current one.

        // Let's try to get current station URI from current speaker
        var currentUri = await _uow.ISonosConnectorRepo.GetCurrentStationAsync(SelectedSpeakerIp);
        var isPlaying = await _uow.ISonosConnectorRepo.IsPlaying(SelectedSpeakerIp);

        if (string.IsNullOrEmpty(currentUri))
        {
             // Just trigger play on all
             foreach (var speaker in _settings.Speakers)
             {
                 await _uow.ISonosConnectorRepo.StartPlaying(speaker.IpAddress);
             }
             await AddLog("Sync Play Started (Resume)", "All speakers");
        }
        else
        {
            // Set URI on all speakers and play
            // Note: This is not true sync (multi-room), it just plays same content independently.
            foreach (var speaker in _settings.Speakers)
            {
                if (speaker.IpAddress == SelectedSpeakerIp) continue; // Already set

                // We need to determine if it is a station or track.
                // The repo has methods for TuneIn and Spotify/Youtube.
                // Getting the exact metadata to replay on another speaker is complex without full UPnP access.
                // Fallback to just StartPlaying if we can't easily clone the stream.

                // For radio stations it is easier if we have the URL.
                if (currentUri.StartsWith("x-rincon-mp3radio://") || currentUri.StartsWith("http"))
                {
                     await _uow.ISonosConnectorRepo.SetTuneInStationAsync(speaker.IpAddress, currentUri);
                }

                await _uow.ISonosConnectorRepo.StartPlaying(speaker.IpAddress);
            }
            await AddLog("Sync Play Started (Cloned URI)", "All speakers");
        }
    }

    private async Task<bool> IsPlaying()
    {
        return await _uow.ISonosConnectorRepo.IsPlaying(SelectedSpeakerIp);
    }

    private async Task SaveSettings()
    {
        await _uow.ISettingsRepo.WriteSettings(_settings!);
    }

    private void ShowAddStationModal() => _addMediaItemModal.Show("Add New Station");
    private void ShowAddSpotifyModal() => _addMediaItemModal.Show("Add New Spotify Item");
    private void ShowAddYouTubeModal() => _addMediaItemModal.Show("Add New YouTube Music Item");

    private async Task SaveNewMediaItem((string Name, string Url) data)
    {
        _addModalError = null;
        _settings ??= new SonosSettings();

        switch (_activeMediaTab)
        {
            case "stations":
                _settings.Stations ??= new List<TuneInStation>();
                if (_settings.Stations.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Station with this name or URL already exists.";
                    return;
                }
                _settings.Stations.Add(new TuneInStation { Name = data.Name, Url = data.Url });
                await AddLog("Station Added", $"{data.Name} ({data.Url})");
                break;
            case "spotify":
                _settings.SpotifyTracks ??= new List<SpotifyObject>();
                 if (_settings.SpotifyTracks.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "Spotify item with this name or URL already exists.";
                    return;
                }
                _settings.SpotifyTracks.Add(new SpotifyObject { Name = data.Name, Url = data.Url });
                await AddLog("Spotify Track Added", $"{data.Name} ({data.Url})");
                break;
            case "youtube":
                _settings.YouTubeMusicCollections ??= new List<YouTubeMusicObject>();
                 if (_settings.YouTubeMusicCollections.Any(s => s.Name == data.Name || s.Url == data.Url))
                {
                    _addModalError = "YouTube item with this name or URL already exists.";
                    return;
                }
                _settings.YouTubeMusicCollections.Add(new YouTubeMusicObject { Name = data.Name, Url = data.Url });
                await AddLog("YouTube Music Link Added", $"{data.Name} ({data.Url})");
                break;
        }
        
        await SaveSettings();
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveStation(TuneInStation station)
    {
        if (_settings?.Stations is null) return;

        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete station '{station.Name}'?");
        if (!confirmed) return;

        _settings.Stations.Remove(station);
        await SaveSettings();

        await AddLog("Station Removed", $"{station.Name} ({station.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveSpotifyTrack(SpotifyObject track)
    {
        if (_settings?.SpotifyTracks is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete track '{track.Name}'?");
        if (!confirmed) return;

        _settings.SpotifyTracks.Remove(track);
        await SaveSettings();

        await AddLog("Spotify Track Removed", $"{track.Name} ({track.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private async Task RemoveYouTubeMusicEntry(YouTubeMusicObject entry)
    {
        if (_settings?.YouTubeMusicCollections is null) return;
        
        var confirmed = await JS.InvokeAsync<bool>("confirm", $"Are you sure you want to delete link '{entry.Name}'?");
        if (!confirmed) return;

        _settings.YouTubeMusicCollections.Remove(entry);
        await SaveSettings();

        await AddLog("YouTube Music Link Removed", $"{entry.Name} ({entry.Url})");
        await InvokeAsync(StateHasChanged);
    }

    private Random _random = new();

    private async Task ShuffleStation()
    {
        if (_settings?.Stations != null && _settings.Stations.Any())
        {
            var randomStation = _settings.Stations[_random.Next(_settings.Stations.Count)].Url;
            await PlayMediaItem(randomStation, "station");
        }
    }

    public async ValueTask DisposeAsync()
    {
        _stationUpdateTimer?.Dispose();
        _stationUpdateTimer = null;

        StopQueueAutoRefresh(true);
        var refreshTask = _queueRefreshTask;
        _queueRefreshTask = null;

        var playbackCts = _playbackTimerCts;
        if (playbackCts is not null)
        {
            _playbackTimerCts = null;
            playbackCts.Cancel();
            playbackCts.Dispose();
        }

        if (refreshTask is not null)
        {
            try
            {
                await refreshTask.ConfigureAwait(false);
            }
            catch (OperationCanceledException)
            {
            }
            catch (ObjectDisposedException)
            {
            }
        }
    }
}
